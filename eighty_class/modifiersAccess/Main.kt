// Практическое задание: «Секретный отсек космического корабля»
// Контекст:
// Ты проектируешь систему управления простым космическим кораблем. У корабля есть открытая информация для всех членов экипажа и секретные системы, доступ к которым строго ограничен.

// Цель задания:
// Закрепить понимание модификаторов private, public, protected и internal на практике, создав классы с разным уровнем доступа к их компонентам.

// Часть 1: Создание базового класса (Открытый отсек)
// Создай класс Spaceship (Космический корабль).

// У корабля должно быть публичное свойство name (название) типа String.

// У корабля должно быть публичное свойство crewCount (количество экипажа) типа Int.

// У корабля должно быть публичное свойство fuel (топливо) типа Double. Изначально 100.0.

// У корабля должен быть публичный метод launch(), который выводит в консоль: "Корабль [name] с экипажем из [crewCount] человек готов к запуску! Топлива: [fuel]%".

// У корабля должен быть приватный метод checkEngine(). Он просто возвращает true (в реальности здесь была бы сложная проверка, но для нас это просто true).

// Метод launch() должен внутри себя вызывать приватный метод checkEngine() и, если проверка прошла (true), выводить "Двигатели проверены. Запуск!", а если нет — "Ошибка двигателя!".
// Задача: Напиши код класса Spaceship. В функции main() создай объект этого класса, задай ему имя, количество экипажа и вызови метод launch(). Убедись, что приватный метод checkEngine() нельзя вызвать напрямую из main().

// Часть 2: Создание класса-наследника (Капитанский мостик)
// Создай класс CommandBridge (Капитанский мостик), который наследуется от Spaceship.

// У мостика должно быть защищенное (protected) свойство accessCode (код доступа) типа String.

// У мостика должен быть публичный метод enterBridge(enteredCode: String). Этот метод должен:

// Сравнивать переданный enteredCode с accessCode.

// Если код верный, выводить сообщение: "Доступ на капитанский мостик разрешен. Статус корабля: [name], топливо: [fuel]%".

// Если код неверный, выводить: "Неверный код доступа!".

// Капитанский мостик должен знать о топливе корабля (fuel), но не должен иметь возможность его изменить напрямую.

// Задача: Напиши код класса CommandBridge. В функции main() создай объект этого класса, унаследовав свойства от Spaceship. Попробуй вызвать метод enterBridge() с правильным и неправильным кодом. Попробуй также обратиться к свойству accessCode из main() — у тебя не должно получиться.

// Часть 3: Модульная система (Секретный отсек в другом файле)
// Представь, что этот код будет в другом файле того же модуля (проекта).

// Создай воображаемый новый файл SecretCompartment.kt и опиши в нем:

// Класс SecretCompartment (Секретный отсек) с внутренним (internal) конструктором, принимающим параметр compartmentId: Int.

// Внутри класса должен быть внутренний метод activate(activationKey: String), который выводит: "Секретный отсек #[compartmentId] активирован ключом: $activationKey".


// Формула для интереса (расчет мощности двигателя):
// Чтобы задание было не совсем абстрактным, добавь в класс Spaceship приватный метод calculateEnginePower().

// Формула: Мощность = (fuel * 10) + (crewCount * 5)

// Метод должен возвращать значение типа Double.

// Измени метод launch(): после фразы "Двигатели проверены. Запуск!" пусть он выводит: "Расчетная мощность двигателей: [результат вызова calculateEnginePower()] усл. ед.".

// Это просто пример, как приватный метод может выполнять внутренние расчеты, используя публичные свойства, но его реализация скрыта от внешнего мира.

fun main(args: Array<String>) {
    var vicram001 = Spaceship("vicram001", 4);
    vicram001.launch();
    // vicram001.checkEngine(); ошибка
    var welCity = CommandBridge("welCity", 4, accessCode = "440422334");
    welCity.enterBridge("23423423423");
    // welCity.accessCode  ошибка
}